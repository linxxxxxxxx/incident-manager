# 事件管理应用程序

## 一 、项目概述
本项目是运用 Java 17 与 Spring Boot 构建的简易事件管理应用程序，专注于事件的创建、更新、删除以及查询功能。其核心在于提供高效的事件管理服务，借助内存存储（incidentMap）与缓存（incidentCache）机制显著提升性能，并依靠读写锁保障多线程环境下的数据安全。同时，通过定期清理过期数据来优化存储资源的利用，确保系统稳定且高效地运行。
## 二 、如何运行
### （一）开发环境准备
确保本地已正确安装 Java 17 和 Maven，并完成如下环境变量配置：  
- Java 环境变量（以 Linux 系统为例）：  
 - - 设定 JAVA_HOME 为 Java 17 的安装路径，如 export JAVA_HOME=/usr/lib/jvm/java-17-openjdk（依实际安装位置调整）。
 - - 将 $JAVA_HOME/bin 添入 PATH 环境变量，通过 export PATH=$PATH:$JAVA_HOME/bin 命令实现，以便在命令行直接调用 java 和 javac 等命令。
- Maven 环境变量（以 Linux 系统为例）:  
- - 配置 MAVEN_HOME 指向 Maven 的安装目录，例如 export MAVEN_HOME=/opt/maven（依据实际安装路径修改）。
- - 把 $MAVEN_HOME/bin 加入 PATH 环境变量，执行 export PATH=$PATH:$MAVEN_HOME/bin 命令，便于在命令行执行 mvn 相关指令。

### （二）项目构建
在项目根目录下执行 mvn clean install 指令，此过程会下载项目所需依赖库，并将项目打包生成可执行的 JAR 文件。

### （三）直接运行项目
运行 java -jar target/incident-manager-1.0-SNAPSHOT.jar 命令（版本号依实际情况而定），默认情况下，项目将监听 8080 端口，用户可通过浏览器或其他 HTTP 客户端工具访问相关 API 接口进行操作。

### （四）Docker 容器化部署
- 构建 Docker 镜像：  
  项目根目录下的 Dockerfile 示例如下：
``` markdown
FROM openjdk:17-jdk-alpine
COPY target/incident-manager-1.0-SNAPSHOT.jar /app/incident-manager.jar
ENTRYPOINT ["java", "-jar", "/app/incident-manager.jar"]
```
在项目根目录执行 docker build -t incident-manager:latest. 命令构建 Docker 镜像，其中 -t 用于指定镜像标签与名称，最后的 . 表示依据当前目录下的 Dockerfile 构建。  

- 运行 Docker 容器：  
  镜像构建成功后，通过 docker run -d -p 8080:8080 incident-manager:latest 命令运行容器，-d 使容器后台运行，-p 将容器内部 8080 端口映射到主机 8080 端口，便于外部访问。

## 三、API 接口说明
1. **创建事件**：
    - **接口地址**：`/incident`（POST请求）
    - **请求参数**：在请求体中传入`Incident`对象的JSON格式数据，包含事件相关属性，如名称、描述。
    ``` json
   {"name":"会议事件","description":"关于项目进度讨论的会议"}
    ```
    - **返回结果**：成功创建返回`201 Created`状态码及创建后的事件对象，参数错误返回`400 Bad Request`，失败返回`500 Internal Server Error`。
2. **更新事件**：
    - **接口地址**：`/incident`（PUT请求）
    - **请求参数**：请求体传入更新后的`Incident`对象JSON数据， body中id为指定要更新的事件ID。
    ``` json
   {"id": 2,"name":"会议事件","description":"关于项目进度讨论的会议"}
    ```
    - **返回结果**：如果事件存在，返回`200 OK`状态码及更新后的事件对象，参数错误返回`400 Bad Request`，若不存在返回`404 Not Found`。
3. **删除事件**：
    - **接口地址**：`/incident{incidentId}`（DELETE请求）
    - **请求参数**：路径参数`incidentId`指定要删除的事件ID。
    - **返回结果**：成功删除返回`200 OK`状态码，参数错误返回`400 Bad Request`，失败返回`500 Internal Server Error`。
4. **获取所有事件列表**：
    - **接口地址**：`/incident`（GET请求）
    - **返回结果**：返回`200 OK`状态码及包含所有事件的列表数据（JSON格式），失败返回`500 Internal Server Error`。
   ``` json
    [
      {
      "id": 1,
      "name": "会议事件1",
      "description": "关于项目进度讨论的会议1",
      "createdDate": "2024-11-29T03:13:06.565+00:00",
      "updatedDate": "2024-11-29T03:13:06.565+00:00"
      },
      {
      "id": 3,
      "name": "会议事件2",
      "description": "关于项目进度讨论的会议2",
      "createdDate": "2024-11-29T03:13:15.110+00:00",
      "updatedDate": "2024-11-29T03:13:15.110+00:00"
      }
    ]
   ```

## 四、单元测试和压力测试

### （一）测试框架及覆盖率情况
项目采用 JUnit 作为单元测试框架，并结合 Mockito 模拟依赖对象，对服务层与控制器层展开单元测试。当前单元测试代码的覆盖率方面，基本涵盖各种正常与异常场景，有力保障代码质量与功能正确性。  
Overall Coverage Summary  

| Package       | Class        | Method      | Branch      | Line        |
|---------------|--------------|-------------|-------------|-------------|
| all classes   | 100% (7/7)   | 97% (32/33) | 46.6% (41/88)| 74.5% (111/149) |


Coverage Breakdown

| Package                          | Class        | Method      | Branch      | Line        |
|----------------------------------|--------------|-------------|-------------|-------------|
| org.example.incidentmanager       | 100% (1/1)   | 50% (1/2)   | -           | 50% (1/2)   |
| org.example.incidentmanager.controller | 100% (1/1)   | 100% (5/5)  | 83.3% (5/6) | 94.7% (18/19) |
| org.example.incidentmanager.exception  | 100% (2/2)   | 100% (6/6)  | -           | 100% (10/10) |
| org.example.incidentmanager.model      | 100% (2/2)   | 100% (10/10)| 41.3% (19/46)| 100% (10/10) |
| org.example.incidentmanager.service     | 100% (1/1)   | 100% (10/10)| 47.2% (17/36)| 66.7% (72/108) |


###  （二）如何运行测试
在项目根目录下，执行 mvn test 命令可运行所有单元测试代码，执行完毕后，命令行终端将展示各个测试用例的执行情况以及最终的测试结果汇总。
对于压力测试，项目推荐使用 JMeter 工具（或者其他合适的压力测试工具，如 Gatling 等），通过编写相应的测试计划，模拟多用户并发访问 API 接口的场景，来评估系统在高负载情况下的性能表现。

## 五、缓存机制
应用程序对查询所有事件列表的功能添加了简单的内存缓存机制，设置了缓存过期时间，在事件有创建、更新、删除操作时会使缓存失效，以保证数据的一致性。
### （一）缓存配置参数
应用程序针对查询所有事件列表的功能添加了内存缓存机制，使用的是 Guava Cache 实现。目前设置的缓存过期时间为  48 小时（可以灵活调整），该时间依据业务场景中事件数据的更新频率以及用户对数据实时性的要求综合确定，旨在保证数据一定时效性的同时，尽可能减少重复查询对系统性能的影响。缓存的最大容量设置为 [具体数值，例如 100000]，当缓存中的数据量接近此容量时，会按照一定的定期淘汰策略进行数据清理，以维持缓存的高效运行

### （二）缓存失效机制
在事件有创建、更新、删除操作时，会触发相应的缓存失效逻辑，确保数据的一致性。例如，在代码层面，当调用创建事件（createIncident 方法）、更新事件（updateIncident 方法）或者删除事件（deleteIncident 方法）时，都会显式地使缓存中对应的事件数据失效（通过调用 incidentCache.invalidate 相关方法实现，具体代码可参考对应服务层的实现类），避免出现数据不一致的情况，即保证缓存中的数据始终与内存存储（incidentMap）中的最新数据保持同步。
## 五、后续扩展方向   
### （一） 优先级排序
- 完善错误处理逻辑（高优先级）：进一步细化各个接口以及业务操作过程中的异常捕获和处理，除了目前简单的状态码返回和日志记录外，增加更友好的用户提示信息以及针对不同类型错误的相应补偿操作，提升系统的稳定性和用户体验。
- 优化缓存策略（中优先级）：根据实际业务中事件数据的访问模式、读写比例等因素，重新评估和调整缓存的配置参数（如过期时间、最大容量、淘汰策略等），并可能引入更高级的缓存管理技术（如分布式缓存等，如果适用），进一步提高系统性能。
- 添加数据库持久化功能（高优先级）：初步计划选用 [具体数据库，如 MySQL 或 PostgreSQL 等] 作为持久化存储，设计合理的数据库表结构，例如事件表将包含 id（主键）、name、createdDate、updatedDate、description 等字段，并建立与其他可能关联表（如用户表、分类表等，如果有相关业务需求）的关系，通过数据访问层（DAO）实现业务逻辑与数据库的交互，保障数据的长期可靠存储。
- 使用更专业的工具进行全面的性能测试（中优先级）：除了目前使用的简单压力测试工具外，引入专业的性能测试平台和分析工具，对系统进行全方位的性能评估，包括但不限于接口响应时间、系统吞吐量、资源利用率等指标的详细分析，根据测试结果针对性地进行性能优化，确保系统在大规模用户场景下的高效稳定运行。
### （二）数据库持久化设计思路
具体的数据库设计将根据详细的业务需求进一步完善和细化（包括字段扩展、索引设计等），确保数据的完整性、一致性以及高效的存储与查询性能。同时，在数据库操作过程中，将充分考虑事务处理、索引优化等关键因素，以提升系统的整体稳定性和响应速度。
## 六、注意事项
- 缓存配置参数（如最大容量、过期时间等）以及相关阈值（如数据过期时间阈值、缓存更新间隔等）均为示例设定，实际应用中需依据业务场景中事件数据的产生频率、数据量大小、访问模式等因素进行性能测试，并灵活调整，以达最佳缓存使用效果与系统性能。
- 前后端跨域问题，暂时在controller层增加@CrossOrigin(origins = "http://localhost:3000")处理。
